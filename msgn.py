import scipy.ndimage
import numpy as np
import scipy.signal


# 2D Gaussian kernel generation of width n and standard deviation std

def gaussian_kernel(n, std, normalized=False):
    gaussian1D = signal.gaussian(n, std)
    gaussian2D = np.outer(gaussian1D, gaussian1D)
    if normalized:
        gaussian2D /= (2*np.pi*(std**2))
    return gaussian2D

# Generates single local normalized image. Variables n and std are for 
# the kernel function above. Variable k can be referenced from the following:
# https://arxiv.org/abs/1403.6613

def gaussian_norm(image,n,std,k):
    kernel = gaussian_kernel(n,std,normalized=False)
    local_mean = scipy.ndimage.filters.convolve(image,kernel)
    difference = image - local_mean
    square_diff = difference**2
    local_std_image = np.sqrt(scipy.ndimage.filters.convolve(square_diff,kernel))
    norm_image = (image - local_mean) / local_std_image
    norm_image = np.arctan(k*norm_image)
    return norm_image

# Final steps in MSGN algorithm for creating a globally-normalized image.
# Image0 is the base image array to be normalized. Images is an array of 
# image arrays generated by varying the kernel width in the previous function.
# Min and max are the min and max pixel values in image0. Variables g and h 
# can be referenced in the paper linked in the previous function. 

def gaussian_mean(image0,images,min,max,gamma,g,h):
    mean_local_norm = np.mean(images,axis=0)
    gamma_transform = ((image0 - min) / (max - min))**(1.0 / gamma)
    image = (h*gamma_transform) + ((1 - h) * g * mean_local_norm)
    return image